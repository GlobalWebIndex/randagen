package gwi.randagen

import gwi.randagen.ArrayUtils.IntArrayPimp

import scala.collection.mutable.ArrayBuffer
import scala.concurrent.Future
import scala.concurrent.duration.FiniteDuration

/**
  * Parallelism information needs to be used mainly by Distributions with explicitly declared number of data-points
  *
  * @param n of threads data-set will be generated by
  */
case class Parallelism(n: Int)

case class ProducerResponse(generatorsTook: FiniteDuration, producersTook: FiniteDuration)

/**
  * High performance producer of random data.
  * It can persist half a billion events with 30GB of data in 10 minutes using just 6GB of Heap.
  * It is able to generate randomly distributed data with predefined cardinality which is the main speed and data volume bottleneck
  */
class EventProducer(eventDefFactory: EventDefFactory, eventGenerator: EventGenerator, eventConsumer: EventConsumer)(p: Parallelism) extends Profiling {

  def generate(batchByteSize: Int, totalEventCount: Int): Future[List[ProducerResponse]] = {
    ArrayUtils
      .range(totalEventCount)
      .shuffle
      .mapAsync(p.n) { it =>
        val (eventDef, gTook) = profile(eventDefFactory(p))
        val (_, pTook) =
          profile {
            it.foldLeft((Option.empty[String], 0, new ArrayBuffer[Array[Byte]](32768))) { case ((lastPathOpt, byteSize, acc), (idx, shuffledIdx)) =>
              def pullEvent = eventGenerator.generate(eventDef, Progress(shuffledIdx, idx, totalEventCount))
              def pushEvents(path: Option[String], loadSize: Int, load: ArrayBuffer[Array[Byte]]) =
                eventConsumer.push(ConsumerRequest(path, idx+1, eventGenerator.format.extension, ArrayUtils.flattenArray(load.toArray, Option(loadSize))))

              val Event(field, pathOpt) = pullEvent
              val bytes = field.getBytes
              if (!it.hasNext) { // last event
                acc.append(bytes)
                pushEvents(pathOpt, byteSize + bytes.length, acc)
                (pathOpt, 0, ArrayBuffer.empty)
              } else if (lastPathOpt.exists(lp => pathOpt.exists(_ != lp)) || byteSize > batchByteSize) { // batch is ready
                pushEvents(lastPathOpt, byteSize, acc)
                (pathOpt, bytes.length, new ArrayBuffer(32768).+=(bytes))
              } else {
                (pathOpt, byteSize + bytes.length, acc.+=(bytes))
              }
            }
          }
        ProducerResponse(gTook, pTook)
      }
    }
}