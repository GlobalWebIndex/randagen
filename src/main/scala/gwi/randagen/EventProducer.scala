package gwi.randagen

import gwi.randagen.ArrayUtils.IntArrayPimp

import scala.collection.mutable.ArrayBuffer
import scala.concurrent.Future
import scala.concurrent.duration.FiniteDuration

/**
  * Parallelism information needs to be used mainly by Distributions with explicitly declared number of data-points
  *
  * @param n of threads data-set will be generated by
  */
case class Parallelism(n: Int)

case class ProducerResponse(generatorsTook: FiniteDuration, producersTook: FiniteDuration)

/**
  * High performance producer of random data.
  * It can persist half a billion events with 30GB of data in 10 minutes using just 6GB of Heap.
  * It is able to generate randomly distributed data with predefined cardinality which is the main speed and data volume bottleneck
  */
class EventProducer(eventDef: EventDef, eventGenerator: EventGenerator, eventConsumer: EventConsumer)(p: Parallelism) extends Profiling {

  def generate(batchEventSize: Int, batchByteSize: Int, totalEventCount: Int): Future[List[ProducerResponse]] = {
    ArrayUtils
      .range(totalEventCount)
      .shuffle
      .mapAsync(p.n) { it =>
        val (fieldDefs, gTook) = profile(eventDef(p))
        val (_, pTook) =
          profile {
            it.foldLeft(0, new ArrayBuffer[Array[Byte]](32768)) { case ((byteSize, acc), (idx, shuffledIdx)) =>
              def pullEvent = eventGenerator.generate(fieldDefs, Progress(shuffledIdx, idx, totalEventCount))
              def pushEvents(loadSize: Int, load: ArrayBuffer[Array[Byte]]) = eventConsumer.push(ConsumerRequest(idx+1, eventGenerator.format.extension, (idx+1)/batchEventSize, loadSize, load.toArray))

              if (!it.hasNext) {
                // last event
                val bytes = pullEvent.getBytes
                acc.append(bytes)
                pushEvents(byteSize + bytes.length, acc)
                0 -> ArrayBuffer.empty
              } else if (byteSize > batchByteSize || acc.length == batchEventSize) {
                // batch is ready
                val bytes = pullEvent.getBytes
                pushEvents(byteSize, acc)
                bytes.length -> new ArrayBuffer(32768).+=(bytes)
              } else {
                val bytes = pullEvent.getBytes
                byteSize + bytes.length -> acc.+=(bytes)
              }
            }
          }
        ProducerResponse(gTook, pTook)
      }
    }
}