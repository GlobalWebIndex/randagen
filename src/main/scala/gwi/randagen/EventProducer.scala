package gwi.randagen

import gwi.randagen.ArrayUtils.IntArrayPimp

import scala.collection.mutable.ArrayBuffer
import scala.concurrent.Future
import scala.concurrent.duration.FiniteDuration

/**
  * Parallelism information needs to be used mainly by Distributions with explicitly declared number of data-points
  *
  * @param n of threads data-set will be generated by
  */
case class Parallelism(n: Int)

case class ProducerResponse(generatorsTook: FiniteDuration, producersTook: FiniteDuration)

/**
  * High performance producer of random data.
  * It can persist half a billion events with 30GB of data in 10 minutes using just 6GB of Heap.
  * It is able to generate randomly distributed data with predefined cardinality which is the main speed and data volume bottleneck
  */
class EventProducer(eventDefFactory: EventDefFactory, eventGenerator: EventGenerator, eventConsumer: EventConsumer)(p: Parallelism) extends Profiling {

  def generate(batchByteSize: Int, totalEventCount: Int): Future[List[ProducerResponse]] = {
    ArrayUtils
      .range(totalEventCount)
      .shuffle
      .mapAsync(p.n) { it =>
        val (eventDef, gTook) = profile(eventDefFactory(p))
        val (_, pTook) =
          profile {
            it.foldLeft(Option.empty[String], 0, new ArrayBuffer[Array[Byte]](32768)) { case ((lastPathOpt, byteSize, acc), (idx, shuffledIdx)) =>
              def pullEvent = eventGenerator.generate(eventDef, Progress(shuffledIdx, idx, totalEventCount))
              def pushEvents(path: String, loadSize: Int, load: ArrayBuffer[Array[Byte]]) =
                eventConsumer.push(ConsumerRequest(path, idx+1, eventGenerator.format.extension, loadSize, load.toArray))

              val Event(path, field) = pullEvent
              val bytes = field.getBytes
              if (!it.hasNext) { // last event
                acc.append(bytes)
                pushEvents(path, byteSize + bytes.length, acc)
                (Some(path), 0, ArrayBuffer.empty)
              } else if (lastPathOpt.exists(_ != path) || byteSize > batchByteSize) { // batch is ready
                pushEvents(lastPathOpt.get, byteSize, acc)
                (Some(path), bytes.length, new ArrayBuffer(32768).+=(bytes))
              } else {
                (Some(path), byteSize + bytes.length, acc.+=(bytes))
              }
            }
          }
        ProducerResponse(gTook, pTook)
      }
    }
}